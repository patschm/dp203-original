{
	"name": "M4_1_1 Warehouse schema",
	"properties": {
		"folder": {
			"name": "Module 4.1"
		},
		"content": {
			"query": "-- Schema on which analysis takes place\nCREATE SCHEMA Main;\nGO;\n\n-- Schema for preparing data\n-- Staging tables are used as temporary storage for data as it's being loaded into the data warehouse. \n-- A typical pattern is to structure the table to make it as efficient as possible to ingest the data from \n-- its external source (often files in a data lake) into the relational database, and then use SQL statements \n-- to load the data from the staging tables into the dimension and fact tables.\nCREATE SCHEMA Staging\nGO;\n\n-- Create Tables for Main schema\n-- Dedicated SQL pools in Synapse Analytics don't support foreign key and unique constraints as found in other relational database systems\n-- INDEXES\n-- While Synapse Analytics dedicated SQL pools support clustered indexes as found in SQL Server, the default index type is clustered columnstore. \n-- This index type offers a significant performance advantage when querying large quantities of data in a typical data warehouse schema and should be used where possible\n-- DISTRIBUTION\n-- Azure Synapse Analytics dedicated SQL pools use a massively parallel processing (MPP) architecture, as opposed to the symmetric multiprocessing (SMP) \n-- architecture used in most OLTP database systems. In an MPP system, the data in a table is distributed for processing across a pool of nodes. \n-- Synapse Analytics supports the following kinds of distribution:\n-- * Hash: A deterministic hash value is calculated for the specified column and used to assign the row to a compute node.\n-- * Round-robin: Rows are distributed evenly across all compute nodes.\n-- * Replicated: A copy of the table is stored on each compute node.\n\n-- Dimension tables\n-- Dimension tables describe business entities, such as products, people, places, and dates. \n-- A dimension table contains a unique key column that uniquely identifies each row in the table. \n-- In fact, it's common for a dimension table to include two key columns:\n-- * a surrogate key that is specific to the data warehouse and uniquely identifies each row in the dimension table in the data warehouse - usually an incrementing integer number.\n-- * an alternate key, often a natural or business key that is used to identify a specific instance of an entity in the transactional source system from which the entity record originated\n--   - such as a product code or a customer ID.\n\n\n-- We use the SNOWFLAKE strategy here\n-- We could also use the STAR strategy\nCREATE TABLE Main.DimCustomers\n(\n    Id BIGINT IDENTITY NOT NULL,\n    AlternateKey BIGINT NULL,\n    FirstName NVARCHAR(255) NOT NULL,\n    LastName NVARCHAR(255) NOT NULL,\n    CompanyName NVARCHAR(255) NOT NULL,\n    StreetName NVARCHAR(255) NOT NULL,\n    Number INT NOT NULL,\n    GeoId BIGINT NOT NULL\n)\nWITH\n(\n    DISTRIBUTION = REPLICATE,\n    CLUSTERED COLUMNSTORE INDEX\n);\n\nCREATE TABLE Main.DimGeo\n(\n    Id BIGINT IDENTITY NOT NULL,\n    City NVARCHAR(255) NOT NULL,\n    Region NVARCHAR(255) NOT NULL,\n    Country NVARCHAR(255) NOT NULL\n)\nWITH\n(\n    DISTRIBUTION = REPLICATE,\n    CLUSTERED COLUMNSTORE INDEX\n);\n\nCREATE TABLE Main.DimBrands\n(\n    Id BIGINT IDENTITY NOT NULL,\n    [Name] NVARCHAR(255) NOT NULL\n)\nWITH\n(\n    DISTRIBUTION = REPLICATE,\n    CLUSTERED COLUMNSTORE INDEX\n);\n\nCREATE TABLE Main.DimProducts\n(\n    Id BIGINT IDENTITY NOT NULL,\n    AlternateKey BIGINT NULL,\n    BrandId BIGINT NOT NULL,\n    [Name] NVARCHAR(255) NOT NULL,\n    Price DECIMAL(10,2) NOT NULL\n)\nWITH\n(\n    DISTRIBUTION = REPLICATE,\n    CLUSTERED COLUMNSTORE INDEX\n);\n\nCREATE TABLE Main.DimDates\n( \n    Id INT NOT NULL,\n    AltKey DATETIME NOT NULL,\n    DayOfMonth INT NOT NULL,\n    DayOfWeek INT NOT NULL,\n    DayName NVARCHAR(15) NOT NULL,\n    MonthOfYear INT NOT NULL,\n    MonthName NVARCHAR(15) NOT NULL,\n    CalendarQuarter INT  NOT NULL,\n    CalendarYear INT NOT NULL\n)\nWITH\n(\n    DISTRIBUTION = REPLICATE,\n    CLUSTERED COLUMNSTORE INDEX\n);\n\nCREATE TABLE Main.FactOrders\n(\n    Id BIGINT NOT NULL,\n    OrderDateId INT NOT NULL,\n    CustomerId BIGINT NOT NULL,\n    ProductId BIGINT NOT NULL,\n    Quantity INT NOT NULL,\n    TotalPrice DECIMAL(10,2) NOT NULL\n)\nWITH\n(\n    DISTRIBUTION = HASH(Id),\n    CLUSTERED COLUMNSTORE INDEX\n);\n\n-- Create Staging tables\n-- Staging tables are used as temporary storage for data as it's being loaded into the data warehouse. \n-- A typical pattern is to structure the table to make it as efficient as possible to ingest the data from its \n-- external source (often files in a data lake) into the relational database, and then use SQL statements to \n-- load the data from the staging tables into the dimension and fact tables.\n--\n-- In Some case you might consider using External Tables.\n-- Products table might be a good option as a external table\n\nCREATE TABLE Staging.DimCustomers\n(\n    Id BIGINT NOT NULL,\n    AlternateKey BIGINT NULL,\n    FirstName NVARCHAR(255) NOT NULL,\n    LastName NVARCHAR(255) NOT NULL,\n    CompanyName NVARCHAR(255) NOT NULL,\n    StreetName NVARCHAR(255) NOT NULL,\n    Number INT NOT NULL,\n    GeoId BIGINT NULL,  -- Needs to be populated later\n    City NVARCHAR(255) NOT NULL,\n    Region NVARCHAR(255) NOT NULL,\n    Country NVARCHAR(255) NOT NULL\n)\nWITH\n(\n    DISTRIBUTION = REPLICATE,\n    CLUSTERED COLUMNSTORE INDEX\n);\n\nCREATE TABLE Staging.DimProducts\n(\n    Id BIGINT NOT NULL,\n    AlternateKey BIGINT NULL,\n    BrandId BIGINT NULL,\n    BrandName NVARCHAR(255) NOT NULL,\n    [Name] NVARCHAR(255) NOT NULL,\n    Price DECIMAL(10,2) NOT NULL\n)\nWITH\n(\n    DISTRIBUTION = REPLICATE,\n    CLUSTERED COLUMNSTORE INDEX\n);\n\nCREATE TABLE Staging.FactOrders\n(\n    Id BIGINT NOT NULL,\n    OrderDate DATETIME2 NOT NULL,\n    OrderDateId INT NULL,\n    CustomerId BIGINT NOT NULL,\n    ProductId BIGINT NOT NULL,\n    Quantity INT NOT NULL,\n    TotalPrice DECIMAL(10,2) NOT NULL\n    \n)\nWITH\n(\n    DISTRIBUTION = HASH(Id),\n    CLUSTERED COLUMNSTORE INDEX\n);",
			"metadata": {
				"language": "sql"
			},
			"currentConnection": {
				"databaseName": "sqlpool",
				"poolName": "sqlpool"
			},
			"resultLimit": 5000
		},
		"type": "SqlQuery"
	}
}